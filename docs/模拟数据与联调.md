# 模拟数据与联调（EMQX / 告警 / 状态变更）

## 1. 我们现阶段是否“模拟数据直接到 EMQX”？

是的。没有真实设备/网关时，**最接近真实链路**的做法是：

`模拟设备（MQTT 发布） → EMQX → 后端订阅解析 → PostgreSQL/Redis（后续 IoTDB） → 前端调用 API/订阅推送`

这样前后端联调不会被“真实设备接入进度”阻塞，同时消息格式、QoS、重连、离线等问题也能提前暴露。

## 2. 如何模拟“真实”的数据、告警与状态变更？

### 2.1 数据（telemetry）更真实的关键点

- 有状态：电梯会在楼层间移动，方向在端点反转，停站时开门，运行时关门
- 有噪声：温度/振动/功率在合理范围内波动
- 有偶发异常：短暂离线、门系统卡滞、振动/温度突增

### 2.2 告警与状态变更更真实的关键点

- 告警来自两种来源：
  - 设备显式上报（topic `.../alert`）
  - 后端规则从 telemetry 派生（例如门卡滞、振动超标）
- 状态变更来自“对比前后状态 + 离线判定”：
  - 收到 telemetry 即在线
  - 一段时间没收到 telemetry 判定离线（后端定时任务）

## 3. 本项目现有实现（后端内置模拟器 + 订阅入库）

后端提供两块能力：

1) **MQTT 订阅入库**（需要开启 `MQTT_ENABLED=true`）  
   - 订阅：`elevator/+/data`、`elevator/+/alert`
   - telemetry 写入：Redis（最新状态）+ PostgreSQL（设备状态表）
   - alert/派生告警写入：PostgreSQL（`alarms`）
   - 离线判定：超过阈值自动写入 OFFLINE 事件

2) **内置模拟器**（需要开启 `SIMULATOR_ENABLED=true`）  
   - 定时发布 telemetry 到 `elevator/{deviceId}/data`
   - 按概率发布困人告警到 `elevator/{deviceId}/alert`
   - 按概率让设备短暂“停发数据”（触发后端离线判定）
   - 按概率产生门卡滞（telemetry `door_status=stuck`，触发派生告警）

## 4. 如何运行（推荐）

### 4.1 先启动依赖

在主工作区（`master`）：
```bash
cd /home/fang/Project/2026elevator-Demo
cp deploy/compose.env.example deploy/compose.env
"/mnt/c/Program Files/Docker/Docker/resources/bin/docker.exe" compose --env-file deploy/compose.env -f deploy/docker-compose.yml up -d
```

确保 EMQX Dashboard 可访问：`http://127.0.0.1:18083`（若你的环境 `localhost` 解析异常，统一用 `127.0.0.1`）

### 4.2 启动后端（monorepo：`backend/`）

```bash
cd /home/fang/Project/2026elevator-Demo/backend

MQTT_ENABLED=true \\
SIMULATOR_ENABLED=true \\
mvn -DskipTests spring-boot:run
```

> 说明：后端默认 MQTT ClientId 为 `elevator-backend-dev`（可用 `MQTT_CLIENT_ID` 覆盖）。

### 4.3 前端联调（需要 token）

```bash
curl --noproxy '*' -H 'Content-Type: application/json' \\
  -d '{"username":"dev","password":"dev"}' \\
  http://127.0.0.1:8080/api/auth/login
```

拿到 `accessToken` 后：
- `GET /api/alarms` 看模拟告警是否产生
- `GET /api/devices` 看设备在线/离线与最新状态
- `GET /api/devices/{deviceId}/realtime` 看单设备实时快照（Redis-first）
- `GET /api/devices/{deviceId}/events` 看状态变更事件（ONLINE/OFFLINE/ALARM_RAISED）
- 告警处置/督办（根据账号权限）：
  - `POST /api/alarms/{id}/process`（接单）
  - `POST /api/alarms/{id}/close`（关闭，需要 `note`）
  - `POST /api/alarms/{id}/transfer`（转工单，demo 记录动作）
  - `POST /api/alarms/{id}/supervise`（督办，demo 记录动作）

> 登录返回会包含 `user` 信息（`role/region/city/permissions`），前端可据此实现三级权限的菜单/按钮控制。
> 可用账号示例（密码均为 `dev`）：
> - 市级执行：`dev`
> - 省级督办：`dev_province`
> - 国级监管：`dev_national`

### 4.4 Windows 开发联调（推荐做法）

- 前端本地开发（Windows）建议通过 Vite 代理转发 `/api/*` 到后端，避免 CORS 与地址切换问题：
  - 前端请求保持 `request.get('/api/...')`
  - Vite `server.proxy` 代理到 `http://localhost:8080`
- 若你希望前端直接请求后端（不走代理），设置 `VITE_API_BASE_URL=http://localhost:8080`。

## 5. MQTT 消息示例（模拟器发布）

### 5.1 telemetry（topic：`elevator/E0001/data`）

```json
{
  "device_id": "E0001",
  "timestamp": 1704614400000,
  "floor": 12,
  "direction": "up",
  "door_status": "closed",
  "speed": 2.5,
  "load": 350,
  "temperature": 25,
  "vibration": 0.05,
  "power": 8.5
}
```

### 5.2 alert（topic：`elevator/E0001/alert`）

```json
{
  "device_id": "E0001",
  "alert_id": "ALT-E0001-1704614400000",
  "alert_level": "red",
  "alert_type": "trapped",
  "alert_desc": "困人告警（模拟）",
  "timestamp": 1704614400000,
  "location": "南山区科技园A栋 6楼",
  "trapped_count": 6
}
```
